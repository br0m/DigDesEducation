## Система управлениями проектами

### 1. Архитектура

![](Архитектура.png)

### 2. Описание модулей

1. **WEB Layer** - принимает запросы и отдает ответ клиенту.
2. **Service Layer** - бизнес-логика, выполняет какие-либо операции над данными для решения поставленных задач.
   - **Services** - интерфейсы и реализующие их классы для работы с данными.
   - **Mapping** - преобразование модели в DTO и обратно.
3. **DTO** - модель представления. Те сущности, с которыми работает представление.
4. **Model** - модель данных, с которой работает слой бизнес-логики.
5. **Repository Layer** - работа с БД.

### 3. Декомпозиция работы
1. Проектирование - архитектура приложения, структура БД, API.
2. Разработка ПО - код, реализующий поставленные задачи.
3. Тестирование - покрытие тестами.
4. Развертывание - сборка проекта, использование Docker Compose, загрузка на Github.
5. ~~Убедить куратора, что я лучший, а все баги это фичи.~~

### 4. Этапы работы
#### 1 этап
* Построить каркас приложения (без подключаемых библиотек)
  * Создать в приложении необходимые модули.
  * Подключить maven. Для каждого модуля прописать pom.xml
  * Создать пакеты в каждом модуле.
  * С помощью maven ваше приложение должно собираться в jar.
  * Дополнительное задание: разработать docker-file, с помощью которого будет собираться образ вашего приложения (пример можно посмотреть, который будет выложен на GitHub)
  * Дополнительное задание: разработать docker-compose файл, который будет запускать собранный образ.(пример можно посмотреть, который будет выложен на GitHub)
  * Обратите внимание на наименование.

* Декомпозировать итоговую работу на блоки задач
  * Постараться разделить одну большую работу на множество блоков (в виде списка, наименование  и описание). Блок это группа задач. В каждом блоке будет список задач, но пока просто разбиваем на блоки. Далее в последующих работах вы будете этот блок разбивать на конкретные задачи.

* Подготовить ваш репозиторий с основными ветками.
  * Сделать основные ветки в репозитории (develop или dev и master ветку)
  * В проекте разработать .gitignore файл, который должен описывать, что не должно пушиться в репозиторий. В репозиторий не должно пушиться скомпилированные классы, сборка - target папка, файлы с настройками среды (например .iml файлы, .idea папка).

#### 2 этап
* Разработать персистентные модели
  * без jpa

* Разработать DTO
  * DTO на вход операций описанных в ТЗ
  * DTO на выход операций описанных в ТЗ

* Реализовать некий dataStorage для хранения сущности (можно одной, например сотрудника) в файле
  * Требования к структуре хранения нет. как к структуре файлов, так и к содержимому (массив байтов, json, xml, какой то свой формат в строках, и т.д)
  * методы create, update, getById, getAll, deleteById
  * для работы с файлами использовать java.io, java.nio
  * выделить интерфейс репозитория, описанный dataStorage должен быть его реализацией
  * jpa подключать не нужно, сервисы и контроллеры реализовывать не нужно (можно по одному для отладки)

#### 3 этап
* Создать физическую модель БД в виде диаграммы.
  * На модели должны быть отражены таблицы(сущности) с необходимыми аттрибутами(в том числе типами) и связи между таблицами.

* Написать и отладить SQL-скрипты для создания схемы БД
  * Создать файлик schema.sql(в resources). В нем должны быть скрипты на создание схемы БД с "нуля".
  * Скрипты должны соответсвовать физической модели.
  * Запустить скрипты на локальной БД, проверить, что схема создалас корректно(нет ошибок, все связи правильно прописаны и тп).
  * Попробовать накидать данных и сделать пару выборок.

* Создать документ с описанием таблиц, колонок и тп.
  * Создать файлик shema.md(в resources либо в каталоге docs). В нем должно краткое описание(что такое, для чего) всех таблиц и аттрибутов.

* Реализовать базовые операции над сущностями с помощью JDBC.
  * Выбрать какую-нибудь сущность(модель) и реализовать для нее CRUD операции + поиск.
  * Поиск должен включать join хотя бы по 2 таблицам. Фильтр на поиск - ДТО, состоящая из нескольких аттрибутов из разных таблиц.

* Подготовить Liquebase-скрипт.
  * Переложить скрипт, созданный в п.2 на Liquebase-скрипт(xml/yaml что хотите). В этом ДЗ запускать не требуется.

#### 4 этап
* Подключить Spring и Spring Boot к проекту
* Создать бины реализующие бизнес логику
* Реализовать персистентную модель с использованием JPA аннотаций
* Реализовать слой работы с хранилищем данных с использованием Spring Data
* Использовать бины репозиториев в сервисном слое для взаимодействия с бд
* Можно подключить Liquibase. Spring Boot имеет автоконфигурацию для него. В пропертях необходимо будет указать путь до скриптов и подключить зависимость

#### 5 этап
* Разработать веб API для итогового проекта с использованием Spring MVC.
* Покрыть веб слой документацией с помощью Spring Doc.
* Описать с помощью аннотаций ваши DTO  и контроллеры.
* Подключить аутентификацию к итоговому проекту с помощью Spring Security. Можно использовать любой тип аутентификации.

#### 6 этап
* Составить тест-кейсы по функциональным требованиям для одного сервиса. Оформить тесты по стандарту в форме таблицы в документе/таблице, включить в проект.
* Реализовать функциональные тесты по тест-кейсам.
* Реализовать как можно много модульных, интеграционных (с использованием testContainers) тестов.
* Подключить log4j2, добавить логов в код, по возможности разделить логи на файлы в зависимости от вашего понимания.

#### 7 этап
* Добавить синхронную/асинхронную отправку уведомлений на почту при назначении задачи на сотрудника по SMTP.
* Для уведомлений предусмотреть возможность подмены реального email на тестовый (например ваш личный) для проверки работоспособности отправки, добавив в тело письма оригинальный email.
* Для текста письма использовать шаблонизатор.
